# Sorting Algorthm

## ✅  왜 배워야 할까?

- 데이터를 정렬하는 방법은 다양하게 존재한다.
- 데이터가 작다면 어떤 알고리즘을 쓰더라도 걸리는 시간은 비슷하다.
- 수많은 데이터를 다룰 때, 사용하는 정렬 알고리즘에 따라 효율이 달라진다.
- ``정렬에 걸리는 시간, 메모리를 효율적으로 사용``하는 경우가 필연적으로 발생한다.

## ✅  시간 복잡도와 공간 복잡도 개념
- 시간 복잡도

시간 복잡도는 알고리즘의 절대적인 실행 시간을 나타내는 것이 아닌 ``알고리즘을 수행하는 데 연산들이 몇 번 이루어지는 지``를 숫자로 표기한다.

- Big-O Complexity Chart

알고리즘의 효율성은 데이터의 입력값의 크기에 따라 영향을 받기 때문에, ``입력값의 크기가 가장 클 경우까지 고려하여 효율성을 계산``한다.

- 공간복잡도

``알고리즘에서 사용하는 메모리의 양``을 나타낸다. 하드웨어의 발전으로 공간 복잡도 보단 시간복잡도를 더 중요하게 고려한다.

## ✅  구현은 쉽지만, 효율은 떨어지는 검색 알고리즘

### 1. 선택 정렬 (Selection Sort)

 - 현재 위치에 들어갈 값을 찾아 정렬하는 방법
 - ``정렬의 여부와 상관없이 배열을 전부 순회하면서 정렬을 진행``하게 된다.
 - 시간복잡도는 ``O(n^2)``, 공간복잡도는 ``O(n)``

### 2. 버블 정렬 (Bubble Sort)

 - ``매번 인접한 두개의 인덱스에 할당된 값을 비교하여 정한 기준에 따라 기준의 값의 위치를 변경``하는 정렬 알고리즘

 - 시간복잡도는 ``O(n^2)``, 공간복잡도는 ``O(n)``

### 3. 삽입 정렬 (Insertion Sort)

 - ``배열의 두번째 인덱스부터 시작``하며, ``현재 위치에서 그 이하의 배열을 비교하며 자신의 위치를 찾아서 그 위치에 값을 삽입하는 정렬``

 - 시간복잡도는 ``O(n^2)``, 공간복잡도는 ``O(n)``

 - ``모두 정렬이 되어 있는 배열의 경우``에는 O(n)의 시간복잡도를 가지고, 거꾸로 되어 있을 경우는 O(n^2)로 차이가 있다.

## ✅  구현은 어렵지만, 효율을 올리는 정렬 알고리즘

### 1. 병합 정렬 (Merge Sort)

 - ``분할 정복 알고리즘 방식``으로 설계된 알고리즘

 - ``하나의 배열을 입력받아, 두개의 배열로 계속 쪼개나간 후,``

 - ``분할이 모두 이루어진 이후에 다시 합치는 과정을 거치며`` 정렬된 하나의 배열을 출력

 - 시간복잡도는 ``O(nlogn)``이며, 공간복잡도는 O(n)

### 2. 퀵 정렬 (Quick Sort)

 - ``분할 정복 알고리즘 방식``으로 설계된 알고리즘(병합 정렬과 마찬가지)

 - ``pivot point`` 라는 기준이 되는 값을 설정하고,

 - ``해당 값을 기준으로 분할과 정렬의 과정을 통해 데이터를 정리``

 - 시간복잡도는 ``O(nlogn)``이며, 공간복잡도는 O(n)

 - 배열이 모두 정리되어 있는 경우 (맨 앞이나 맨 뒤의 숫자가 가장 크거나 작으면), 총 분할 과정이 N번만큼 일어나므로, 시간 복잡도는 O(n^2)이 된다.

### 3. 힙 정렬 (Heap Sort)

 - ``힙 트리 자료구조를 사용하여 데이터를 정렬``하는 알고리즘

 - ``최대 힙, 최소 힙 트리의 구조상 루트 노드에 최대값, 최소값이 항상 존재``하기 때문에, 힙 구조를 사용하여 정렬과정을 거치게 된다.

 - 시간복잡도는 ``O(nlogn)``이며, 공간복잡도는 O(n)


<br />
<br />
<br />
<br />
출처: https://www.youtube.com/watch?v=FYeMC--iFcU



